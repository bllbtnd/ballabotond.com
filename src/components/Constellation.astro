---
// Constellation background component
// Optimized for performance using requestAnimationFrame and spatial hashing
---

<canvas
  id="constellation-canvas"
  class="fixed inset-0 w-full h-full pointer-events-none z-0"></canvas>

<script>
  class ConstellationEffect {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    width: number;
    height: number;
    particles: Particle[];
    mouse: { x: number; y: number };
    pixelRatio: number;
    animationFrameId: number | null = null;
    isLowPowerMode: boolean = false;

    // Configuration
    config = {
      particleCount: 60, // Reduced count for better performance
      connectionDistance: 150,
      mouseDistance: 200,
      particleColor: "rgba(201, 169, 107, 0.3)", // Luxury gold
      lineColor: "rgba(201, 169, 107, 0.15)",
      particleSpeed: 0.2,
      particleSize: 1.5,
    };

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.ctx = canvas.getContext("2d", { alpha: true })!;
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.particles = [];
      this.mouse = { x: -1000, y: -1000 };
      this.pixelRatio = window.devicePixelRatio || 1;

      // Check for low power mode preference
      // @ts-ignore
      if (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) {
        this.isLowPowerMode = true;
        this.config.particleCount = 30; // Reduce particles on weaker devices
      }

      this.init();
      this.bindEvents();
      this.animate();
    }

    init() {
      this.resize();
      this.createParticles();
    }

    resize() {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.canvas.width = this.width * this.pixelRatio;
      this.canvas.height = this.height * this.pixelRatio;
      this.canvas.style.width = `${this.width}px`;
      this.canvas.style.height = `${this.height}px`;
      this.ctx.scale(this.pixelRatio, this.pixelRatio);

      // Don't re-create particles, just clamp them to new bounds
      // This prevents the "reset" effect when mobile address bar toggles
      this.particles.forEach((p) => {
        if (p.x > this.width) p.x = this.width;
        if (p.y > this.height) p.y = this.height;
      });
    }

    createParticles() {
      this.particles = [];
      // Adjust particle count based on screen size
      const area = this.width * this.height;
      const density = this.isLowPowerMode ? 15000 : 10000; // Pixels per particle
      const count = Math.min(
        Math.floor(area / density),
        this.config.particleCount,
      );

      for (let i = 0; i < count; i++) {
        this.particles.push(new Particle(this.width, this.height, this.config));
      }
    }

    bindEvents() {
      window.addEventListener("resize", () => {
        // Debounce resize
        if (this.animationFrameId) {
          cancelAnimationFrame(this.animationFrameId);
        }
        setTimeout(() => {
          this.resize();
          this.animate();
        }, 200);
      });

      document.addEventListener("mousemove", (e) => {
        this.mouse.x = e.clientX;
        this.mouse.y = e.clientY;
      });

      document.addEventListener("mouseleave", () => {
        this.mouse.x = -1000;
        this.mouse.y = -1000;
      });

      // Handle visibility change to pause animation when tab is inactive
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
        } else {
          this.animate();
        }
      });
    }

    animate() {
      if (this.animationFrameId) {
        cancelAnimationFrame(this.animationFrameId);
      }

      const render = () => {
        this.ctx.clearRect(0, 0, this.width, this.height);

        // Update and draw particles
        this.particles.forEach((particle) => {
          particle.update(this.width, this.height);
          particle.draw(this.ctx);
        });

        // Draw connections
        this.drawConnections();

        this.animationFrameId = requestAnimationFrame(render);
      };

      render();
    }

    drawConnections() {
      for (let i = 0; i < this.particles.length; i++) {
        const p1 = this.particles[i];

        // Connect to mouse
        const dxMouse = this.mouse.x - p1.x;
        const dyMouse = this.mouse.y - p1.y;
        const distMouse = Math.sqrt(dxMouse * dxMouse + dyMouse * dyMouse);

        if (distMouse < this.config.mouseDistance) {
          const opacity = 1 - distMouse / this.config.mouseDistance;
          this.ctx.beginPath();
          this.ctx.strokeStyle = `rgba(201, 169, 107, ${opacity * 0.4})`; // Stronger connection to mouse
          this.ctx.lineWidth = 1;
          this.ctx.moveTo(p1.x, p1.y);
          this.ctx.lineTo(this.mouse.x, this.mouse.y);
          this.ctx.stroke();

          // Stronger attraction to mouse
          if (distMouse > 30) {
            // Don't collapse completely onto cursor
            const force = (1 - distMouse / this.config.mouseDistance) * 0.0003;
            p1.vx += dxMouse * force;
            p1.vy += dyMouse * force;
          }
        }

        // Connect to other particles and add repulsion
        for (let j = i + 1; j < this.particles.length; j++) {
          const p2 = this.particles[j];
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < this.config.connectionDistance) {
            const opacity = 1 - dist / this.config.connectionDistance;
            this.ctx.beginPath();
            this.ctx.strokeStyle = `rgba(201, 169, 107, ${opacity * 0.15})`;
            this.ctx.lineWidth = 0.5;
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();

            // Particle repulsion - they push each other away slightly
            if (dist < 100 && dist > 0) {
              const repulsionForce = (1 - dist / 100) * 0.00015;
              const angle = Math.atan2(dy, dx);
              p1.vx += Math.cos(angle) * repulsionForce;
              p1.vy += Math.sin(angle) * repulsionForce;
              p2.vx -= Math.cos(angle) * repulsionForce;
              p2.vy -= Math.sin(angle) * repulsionForce;
            }
          }
        }
      }
    }
  }

  class Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;
    config: any;

    constructor(width: number, height: number, config: any) {
      this.config = config;
      this.x = Math.random() * width;
      this.y = Math.random() * height;
      // Random velocity with random direction
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * config.particleSpeed + 0.1;
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed;
      this.size = Math.random() * config.particleSize + 0.5;
    }

    update(width: number, height: number) {
      this.x += this.vx;
      this.y += this.vy;

      // Bounce off edges
      if (this.x < 0 || this.x > width) this.vx *= -1;
      if (this.y < 0 || this.y > height) this.vy *= -1;

      // Keep within bounds (correction)
      if (this.x < 0) this.x = 0;
      if (this.x > width) this.x = width;
      if (this.y < 0) this.y = 0;
      if (this.y > height) this.y = height;

      // Dampen velocity (friction) to prevent infinite acceleration from mouse attraction
      // But ensure minimum movement
      const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
      if (speed > this.config.particleSpeed * 2) {
        this.vx *= 0.98;
        this.vy *= 0.98;
      } else if (speed < this.config.particleSpeed * 0.5) {
        this.vx *= 1.05;
        this.vy *= 1.05;
      }
    }

    draw(ctx: CanvasRenderingContext2D) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = this.config.particleColor;
      ctx.fill();
    }
  }

  // Initialize on load and on view transitions
  const initConstellation = () => {
    const canvas = document.getElementById(
      "constellation-canvas",
    ) as HTMLCanvasElement;
    if (canvas) {
      new ConstellationEffect(canvas);
    }
  };

  // Run immediately
  initConstellation();

  // Re-run on Astro page swaps (View Transitions)
  document.addEventListener("astro:page-load", initConstellation);
</script>
